# 1.只出现一次的数字 top100

136.给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

思路：

重复的数字异或为0，0异或一个数等于他本身，则所有数字异或后等于那个元素。

1 ^ 1 ^ 2 = 2

	class Solution {
	    public int singleNumber(int[] nums) {
	        int result = 0;
	        for(int num : nums){
	            result ^= num;
	        }
	        return result;
	    }
	}

# 2.多数元素 top100

169.给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1：

  输入：nums = [3,2,3]
  输出：3

思路：Boyer-Moore 投票算法，如果我们把众数记为 +1+1+1，把其他数记为 −1-1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。

Boyer-Moore 算法的详细步骤：

- 我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

- 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

  - 如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

  - 如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

- 在遍历完成后，candidate 即为整个数组的众数。

原理：count一定不会为负数，每次count减到0的时候，证明前面的众数和非众数的数量相同，那么后面的数一定会有众数。因此最后count大于0的数，一定为正数。

    class Solution {
        public int majorityElement(int[] nums) {
            int majorityElement = 0;
            int count = 0;
            for(int num : nums){
                if(count == 0){
                    majorityElement = num;
                }
                if(majorityElement == num){
                    count++;
                }else {
                    count--;
                }
            }
            return majorityElement;
        }
    }
