## 1. 把数组中的 0 移到末尾 ##

283.给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

	输入: [0,1,0,3,12]
	输出: [1,3,12,0,0]

说明:

1. 必须在原数组上操作，不能拷贝额外的数组。
1. 尽量减少操作次数。

思路：

将非0数移到前面，然后将后面全变0.

	class Solution {
	    public void moveZeroes(int[] nums) {
	        int index = 0;
	        for(int num : nums){
	            if(num != 0){
	                nums[index] = num;
	                index++;
	            }
	        }
	        for(int i = index; i < nums.length; i++){
	            nums[i] = 0;
	        }
	    }
	}

## 2. 改变矩阵维度

566.在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

	输入: 
	nums = 
	[[1,2],
	 [3,4]]
	r = 1, c = 4
	输出: 
	[[1,2,3,4]]
	解释:
	行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。

思路：

遍历。

	class Solution {
	    public int[][] matrixReshape(int[][] nums, int r, int c) {
	        int m = nums.length;//原矩阵的行数
	        int n = nums[0].length;//原矩阵的列数
	        if(m * n != r * c) return nums;
	        int index = 0;
	        int[][] result = new int[r][c];
	        for(int i = 0; i < r; i++)
	            for(int j = 0; j < c; j++){
	                result[i][j] = nums[index/n][index%n];
	                index++;
	            }
	        return result;
	    }
	}

## 3. 找出数组中最长的连续 1 ##

485.给定一个二进制数组， 计算其中最大连续1的个数。

	输入: [1,1,0,1,1,1]
	输出: 3
	解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.

思路：

使用两个变量存储，一个存当前连续个数，一个存最大连续个数。

	class Solution {
	    public int findMaxConsecutiveOnes(int[] nums) {
	        int max = 0;
	        int cur = 0;
	        for(int num : nums){
	            if(num == 1){
	                cur++;
	                max = Math.max(max,cur);
	            }
	            else cur = 0;
	        }
	        return max;
	
	    }
	}

## 4. 有序矩阵查找 ##

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

	[
	  [1,   4,  7, 11, 15],
	  [2,   5,  8, 12, 19],
	  [3,   6,  9, 16, 22],
	  [10, 13, 14, 17, 24],
	  [18, 21, 23, 26, 30]
	]

	给定 target = 5，返回 true。
	给定 target = 20，返回 false。

思路： 

从[0][n-1]的位置开始寻找，若目标值大于该值，则行数加，若目标值小于该值，则列数减。

	class Solution {
	    public boolean searchMatrix(int[][] matrix, int target) {
	        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
	        int row = matrix.length; // 行
	        int colmn = matrix[0].length;//列
	        int m = 0, n = colmn - 1;
	        while(m < row && n >= 0){
	            if(target == matrix[m][n]) return true;
	            if(target > matrix[m][n]) m++; //行数加
	            else n--; //列数减
	        }
	        return false;
	    }
	}

## 5. 有序矩阵的 Kth Element ##

378.给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。

请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

	matrix = [
	   [ 1,  5,  9],
	   [10, 11, 13],
	   [12, 13, 15]
	],
	k = 8,
	
	返回 13。

思路：

二分查找。

通过统计数量来查找。

找使其成立的最左边界。

	class Solution {
	    public int kthSmallest(int[][] matrix, int k) {
	        int n = matrix.length;
	        int l = matrix[0][0], h = matrix[n-1][n-1];
	        while(l < h){
	            int mid = l + (h - l)/2;
	            int cnt = 0;
	            for(int i = 0; i < n; i++)
	                for(int j = 0; j < n && matrix[i][j] <= mid; j++){
	                    cnt++;
	                }
	            if(cnt >= k) h = mid;
	            else l = mid + 1;
	        }
	        return l;
	
	    }
	}

## 6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数 ##

645.集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。

给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

	输入: nums = [1,2,2,4]
	输出: [2,3]

思路：

排序，先寻找重复的。

缺失的通过比较前后两个值的差值是否大于1.

有两种特殊情况，缺失第一个和缺失最后一个。

	class Solution {
	    public int[] findErrorNums(int[] nums) {
	        Arrays.sort(nums);
	        int dup = -1;
	        int miss = 1;//如果缺失的是1，则该值不会更改
	        for(int i = 1; i < nums.length; i++){
				//寻找重复的值
	            if(nums[i] == nums[i-1]){
	                dup = nums[i];
	            }
				//寻找缺失的值
	            if(nums[i] - nums[i-1] > 1){
	                miss = nums[i] - 1;
	            }
	
	        }
	        //判断缺失的是否为最后一个
	        if(nums[nums.length-1] != nums.length){
	            miss = nums.length;
	        }
	        return new int[]{dup,miss};
	    }
	}

## 7. 找出数组中重复的数，数组值在 [1, n] 之间 ##

287.

	输入: [1,3,4,2,2]
	输出: 2

说明：

- 不能更改原数组（假设数组是只读的）。
- 只能使用额外的 O(1) 的空间。
- 时间复杂度小于 O(n2) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。

思路：

二分查找，如果小于等于mid的数的数量大于mid的，则重复的数在[l,mid]里，也可能是mid。

这里二分查找是通过统计数量来查找的与第5题相似。

	class Solution {
	    public int findDuplicate(int[] nums) {
	        int l = 0, h = nums.length - 1;
	        while(l < h){
	            int m = l+(h-l)/2;
	            int cnt = 0;
	            for(int i = 0; i < nums.length; i++){
	                if(nums[i]<=m) cnt++;
	            }
	            if(cnt>m) h = m;
	            else l = m+1;
	        }
	        return l;
	
	    }
	}

## 8. 数组相邻差值的个数 ##

667.给定两个整数 n 和 k，你需要实现一个数组，这个数组包含从 1 到 n 的 n 个不同整数，同时满足以下条件：

① 如果这个数组是 [a1, a2, a3, ... , an] ，那么数组 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数；.

② 如果存在多种答案，你只需实现并返回其中任意一种.

	输入: n = 3, k = 1
	输出: [1, 2, 3]
	解释: [1, 2, 3] 包含 3 个范围在 1-3 的不同整数， 并且 [1, 1] 中有且仅有 1 个不同整数 : 1

	输入: n = 3, k = 2
	输出: [1, 3, 2]
	解释: [1, 3, 2] 包含 3 个范围在 1-3 的不同整数， 并且 [2, 1] 中有且仅有 2 个不同整数: 1 和 2

思路：

让前 k+1 个元素构建出 k 个不相同的差值，序列为：1, k+1, 2, k, 3, k-1, ... k/2, k/2+1.

	class Solution {
	    public int[] constructArray(int n, int k) {
	        int[] result = new int[n];
	        result[0] = 1;
	        for(int i = 1, interval = k; i < k+1; i++, interval--){
	            result[i] = i % 2 == 1 ? result[i-1] + interval : result[i-1] - interval;
	        }
	        for(int i = k+1; i < n; i++){
	            result[i] = i+1;
	        }
	        return result;
	    }
	}

## 9. 数组的度 ##

697.给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

	输入: [1,2,2,3,1,4,2]
	输出: 6

思路：使用三个Hashmap，一个储存各个数值出现次数，一个储存一个数的最左坐标，一个储存一个数的最右坐标

	class Solution {
	    public int findShortestSubArray(int[] nums) {
	        Map<Integer, Integer> left = new HashMap<>();
	        Map<Integer, Integer> right = new HashMap<>();
	        Map<Integer, Integer> cnt = new HashMap<>();
	
	        for(int i = 0; i<nums.length; i++){
	            int x = nums[i];
	            if(left.get(x) == null) left.put(x, i);
	            right.put(x, i);
	            cnt.put(x, cnt.getOrDefault(x,0)+1);
	        }
	
	        int max = 0;
	        for(int num : nums){
	            max = Math.max(cnt.get(num), max);
	        }
	        int result = nums.length;
	        for(int i = 0; i < nums.length; i++){
	            int x = nums[i];
	            if(cnt.get(x)!=max) continue;
	
	            int l = left.get(x);
	            int r = right.get(x);
	            
	            result = Math.min(result, r-l+1);
	        }
	        return result;
	
	    }
	}

## 10. 对角元素相等的矩阵 ##

如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。

给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。

	输入: 
	matrix = [
	  [1,2,3,4],
	  [5,1,2,3],
	  [9,5,1,2]
	]
	输出: True
	解释:
	在上述矩阵中, 其对角线为:
	"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"。
	各条对角线上的所有元素均相同, 因此答案是True。

思路：

最左列与最上行都是第一个元素，无需验证，只需要验证其他元素是否等于上一个对角元素。

	class Solution {
	    public boolean isToeplitzMatrix(int[][] matrix) {
	        int m = matrix.length, n = matrix[0].length;
	        for(int i = 1; i < m; i++)
	            for(int j = 1; j < n; j++){
	                if(matrix[i][j] != matrix[i-1][j-1]) return false;
	            }
	        return true;
	    }
	}

## 11. 嵌套数组 ##

565.索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。

假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。

	输入: A = [5,4,0,3,1,6,2]
	输出: 4
	解释: 
	A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.
	
	其中一种最长的 S[K]:
	S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}

思路：

因为每次生成的链都是循环的，对访问过的元素进行标记，下一次不再访问该元素，以免冗余。

	class Solution {
	    public int arrayNesting(int[] nums) {
	        int max = 0;
	        for(int i = 0; i < nums.length; i++){
	            int cnt = 0;
	            for(int j = i; nums[j] != -1;){
	                int t = nums[j];
	                nums[j] = -1;//对访问过的数值进行标记
	                j = t;
	                cnt++;
	            }
	            max = Math.max(max,cnt);
	        }
	        return max;
	    }
	}

## 12. 分隔数组 ##

769.数组arr是[0, 1, ..., arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

	输入: arr = [4,3,2,1,0]
	输出: 1
	解释:
	将数组分成2块或者更多块，都无法得到所需的结果。
	例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。

	输入: arr = [1,0,2,3,4]
	输出: 4
	解释:
	我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
	然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。

思路：

记录排序后能在原位置或者本身就在原位置元素的数量。

	class Solution {
	    public int maxChunksToSorted(int[] arr) {
	        if(arr == null) return 0;
	        int result = 0;
	        int right = arr[0];
	        for(int i = 0; i < arr.length; i++){
	            right = Math.max(right, arr[i]);//排序后能在原位置或者本身就在原位置
	            if(right == i) result++;
	        }
	        return result;
	    }
	}





