## 1. 把数组中的 0 移到末尾 ##

283.给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

	输入: [0,1,0,3,12]
	输出: [1,3,12,0,0]

说明:

1. 必须在原数组上操作，不能拷贝额外的数组。
1. 尽量减少操作次数。

思路：

将非0数移到前面，然后将后面全变0.

	class Solution {
	    public void moveZeroes(int[] nums) {
	        int index = 0;
	        for(int num : nums){
	            if(num != 0){
	                nums[index] = num;
	                index++;
	            }
	        }
	        for(int i = index; i < nums.length; i++){
	            nums[i] = 0;
	        }
	    }
	}

## 2. 改变矩阵维度

566.在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

	输入: 
	nums = 
	[[1,2],
	 [3,4]]
	r = 1, c = 4
	输出: 
	[[1,2,3,4]]
	解释:
	行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。

思路：

遍历。

	class Solution {
	    public int[][] matrixReshape(int[][] nums, int r, int c) {
	        int m = nums.length;//原矩阵的行数
	        int n = nums[0].length;//原矩阵的列数
	        if(m * n != r * c) return nums;
	        int index = 0;
	        int[][] result = new int[r][c];
	        for(int i = 0; i < r; i++)
	            for(int j = 0; j < c; j++){
	                result[i][j] = nums[index/n][index%n];
	                index++;
	            }
	        return result;
	    }
	}

## 3. 找出数组中最长的连续 1 ##

485.给定一个二进制数组， 计算其中最大连续1的个数。

	输入: [1,1,0,1,1,1]
	输出: 3
	解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.

思路：

使用两个变量存储，一个存当前连续个数，一个存最大连续个数。

	class Solution {
	    public int findMaxConsecutiveOnes(int[] nums) {
	        int max = 0;
	        int cur = 0;
	        for(int num : nums){
	            if(num == 1){
	                cur++;
	                max = Math.max(max,cur);
	            }
	            else cur = 0;
	        }
	        return max;
	
	    }
	}

## 4. 有序矩阵查找 ##

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

	[
	  [1,   4,  7, 11, 15],
	  [2,   5,  8, 12, 19],
	  [3,   6,  9, 16, 22],
	  [10, 13, 14, 17, 24],
	  [18, 21, 23, 26, 30]
	]

	给定 target = 5，返回 true。
	给定 target = 20，返回 false。

思路： 

从[0][n-1]的位置开始寻找，若目标值大于该值，则行数加，若目标值小于该值，则列数减。

	class Solution {
	    public boolean searchMatrix(int[][] matrix, int target) {
	        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
	        int row = matrix.length; // 行
	        int colmn = matrix[0].length;//列
	        int m = 0, n = colmn - 1;
	        while(m < row && n >= 0){
	            if(target == matrix[m][n]) return true;
	            if(target > matrix[m][n]) m++; //行数加
	            else n--; //列数减
	        }
	        return false;
	    }
	}

## 5. 有序矩阵的 Kth Element ##

378.给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。

请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

	matrix = [
	   [ 1,  5,  9],
	   [10, 11, 13],
	   [12, 13, 15]
	],
	k = 8,
	
	返回 13。

思路：

二分查找。

通过统计数量来查找。

找使其成立的最左边界。

	class Solution {
	    public int kthSmallest(int[][] matrix, int k) {
	        int n = matrix.length;
	        int l = matrix[0][0], h = matrix[n-1][n-1];
	        while(l < h){
	            int mid = l + (h - l)/2;
	            int cnt = 0;
	            for(int i = 0; i < n; i++)
	                for(int j = 0; j < n && matrix[i][j] <= mid; j++){
	                    cnt++;
	                }
	            if(cnt >= k) h = mid;
	            else l = mid + 1;
	        }
	        return l;
	
	    }
	}

## 6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数 ##

645.集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。

给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

	输入: nums = [1,2,2,4]
	输出: [2,3]

思路：

排序，先寻找重复的。

缺失的通过比较前后两个值的差值是否大于1.

有两种特殊情况，缺失第一个和缺失最后一个。

	class Solution {
	    public int[] findErrorNums(int[] nums) {
	        Arrays.sort(nums);
	        int dup = -1;
	        int miss = 1;//如果缺失的是1，则该值不会更改
	        for(int i = 1; i < nums.length; i++){
				//寻找重复的值
	            if(nums[i] == nums[i-1]){
	                dup = nums[i];
	            }
				//寻找缺失的值
	            if(nums[i] - nums[i-1] > 1){
	                miss = nums[i] - 1;
	            }
	
	        }
	        //判断缺失的是否为最后一个
	        if(nums[nums.length-1] != nums.length){
	            miss = nums.length;
	        }
	        return new int[]{dup,miss};
	    }
	}

## 7. 找出数组中重复的数，数组值在 [1, n] 之间 ##

287.

	输入: [1,3,4,2,2]
	输出: 2

说明：

- 不能更改原数组（假设数组是只读的）。
- 只能使用额外的 O(1) 的空间。
- 时间复杂度小于 O(n2) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。

思路：

二分查找，如果小于等于mid的数的数量大于mid的，则重复的数在[l,mid]里，也可能是mid。

这里二分查找是通过统计数量来查找的与第5题相似。

	class Solution {
	    public int findDuplicate(int[] nums) {
	        int l = 0, h = nums.length - 1;
	        while(l < h){
	            int m = l+(h-l)/2;
	            int cnt = 0;
	            for(int i = 0; i < nums.length; i++){
	                if(nums[i]<=m) cnt++;
	            }
	            if(cnt>m) h = m;
	            else l = m+1;
	        }
	        return l;
	
	    }
	}



