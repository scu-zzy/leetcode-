深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此。

- 1.数字键盘组合
- 2.IP 地址划分
- 剑指27.字符串的排列
- 剑指65.矩阵中的路径

# BFS #

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/95903878-725b-4ed9-bded-bc4aae0792a9.jpg)

广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。

第一层：

- 0 -> {6,2,1,5}

第二层：

- 6 -> {4}
- 2 -> {}
- 1 -> {}
- 5 -> {3}

第三层：

- 4 -> {}
- 3 -> {}

每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di <= dj。利用这个结论，可以求解最短路径等 最优解 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。

在程序实现 BFS 时需要考虑以下问题：

- 队列：用来存储每一轮遍历得到的节点；
- 标记：对于遍历过的节点，应该将它标记，防止重复遍历。


# DFS #

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/74dc31eb-6baa-47ea-ab1c-d27a0ca35093.png)

广度优先搜索一层一层遍历，每一层得到的所有新节点，要用队列存储起来以备下一层遍历的时候再遍历。
而深度优先搜索在得到一个新节点时立即对新节点进行遍历：从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。
从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 可达性 问题。
在程序实现 DFS 时需要考虑以下问题：

- 栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
- 标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。

# 回溯 #

Backtracking（回溯）属于 DFS。

- 普通 DFS 主要用在 可达性问题 ，这种问题只需要执行到特点的位置然后返回即可。
- 而 Backtracking 主要用于求解 排列组合 问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：

- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

## 1. 数字键盘组合 ##

17.给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

	输入："23"
	输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].


----------

	class Solution {
	    private static final String[] KEYS = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
	    StringBuilder sb = new StringBuilder();//用于构造字符串
	    List<String> result = new ArrayList<>();//保存结果
	    public List<String> letterCombinations(String digits) {
	        if(digits.length() == 0) return result;
	        if(digits.length() == sb.length()){
	            result.add(sb.toString());
	            return result;//虚假的返回
	        }
	        int cur = digits.charAt(sb.length()) - '0';
	        String letters = KEYS[cur];
	        for(char c : letters.toCharArray()){
	            sb.append(c);
	            letterCombinations(digits);
	            sb.deleteCharAt(sb.length()-1);
	        }
	        return result;
	    }
	}

## 2. IP 地址划分 ##

93.给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。

	输入: "25525511135"
	输出: ["255.255.11.135", "255.255.111.35"]

----------

	class Solution {
	    StringBuilder sb = new StringBuilder();
	    List<String> result = new ArrayList<>();
	    int k = -1;//用于记录此时在划分第几个整数
	    public List<String> restoreIpAddresses(String s) {
	        k++;
	        //已经分好四个整数或者已经将字符串分完
	        if(k == 4 || s.length() == 0){
	            if(k == 4 && s.length() == 0){//恰好分完
	                result.add(sb.toString());
	            }
	            return result;//虚假的返回
	        }
	
	        for(int i = 0; i < s.length() && i <= 2; i++){
	            if(i != 0 && s.charAt(0) == '0'){//0后面不能跟其他数
	                break;
	            }
	            String part = s.substring(0, i+1);
	            if(Integer.valueOf(part) <= 255) {
	                if(sb.length() != 0){//第一个整数前不用加
	                    part = "." + part;
	                }
	                sb.append(part);
	                restoreIpAddresses(s.substring(i+1));
	                sb.delete(sb.length() - part.length(), sb.length());
	                k--;//k也要复原
	            }
	        }
	        return result;
	    }
	}

## 剑指27.字符串的排列 ##

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

> 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

思路：

回溯。

固定A不动，然后交换B与C，从而得到"ABC" 和 "ACB"
同理，对于"BAC"、"BCA" 、"CAB"和"CBA"是同样道理。
当两个字符相同时，不应该交换。

- 递归函数的功能：dfs(int pos, string s), 表示固定字符串s的pos下标的字符s[pos] 
- 递归终止条件：当pos+1 == s.length()的时候，终止，表示对最后一个字符进行固定，也就说明，完成了一次全排列 
- 下一次递归：dfs(pos+1, s), 很显然，下一次递归就是对字符串的下一个下标进行固定

回溯：每次递归完成后，须重新交换回来。

	import java.util.ArrayList;
	import java.util.Collections;
	public class Solution 
	{
	    public ArrayList<String> Permutation(String str)
	    {
	        ArrayList<String> res=new ArrayList<String>();
	        if(str.length()==0||str==null)return res;
	        int n= str.length();
	        helper(res,0,str.toCharArray());
	        Collections.sort(res);
	        return res;
	         
	    }
	    public void helper( ArrayList<String> res,int index,char []s)
	    {
	        if(index==s.length-1)res.add(new String(s));
	        for(int i=index;i<s.length;i++)
	        {
	            if(i==index||s[index]!=s[i])
	            {
	                swap(s,index,i);
	                helper(res,index+1,s);
	                swap(s,index,i);
	            }
	        }
	         
	    }
	     
	    public void swap(char[]t,int i,int j)
	     {
	        char c=t[i];
	        t[i]=t[j];
	        t[j]=c;
	    }
	}

## 剑指65.矩阵中的路径 ##

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 

思路：

回溯。

	public class Solution {
	    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
	    {
	        //标志位，初始化为false
	        boolean[] flag = new boolean[matrix.length];
	        for(int i=0;i<rows;i++){
	            for(int j=0;j<cols;j++){
	                 //循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法
	                 if(judge(matrix,i,j,rows,cols,flag,str,0)){
	                     return true;
	                 }
	            }
	        }
	        return false;
	    }
	     
	    //judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)
	    private boolean judge(char[] matrix,int i,int j,int rows,int cols,boolean[] flag,char[] str,int k){
	        //先根据i和j计算匹配的第一个元素转为一维数组的位置
	        int index = i*cols+j;
	        //递归终止条件
	        if(i<0 || j<0 || i>=rows || j>=cols || matrix[index] != str[k] || flag[index] == true)
	            return false;
	        //若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可
	        if(k == str.length-1)
	            return true;
	        //要走的第一个位置置为true，表示已经走过了
	        flag[index] = true;
	         
	        //回溯，递归寻找，每次找到了就给k加一，找不到，还原
	        if(judge(matrix,i-1,j,rows,cols,flag,str,k+1) ||
	           judge(matrix,i+1,j,rows,cols,flag,str,k+1) ||
	           judge(matrix,i,j-1,rows,cols,flag,str,k+1) ||
	           judge(matrix,i,j+1,rows,cols,flag,str,k+1)  )
	        {
	            return true;
	        }
	        //走到这，说明这一条路不通，还原，再试其他的路径
	        flag[index] = false;
	        return false;
	    }
	}

