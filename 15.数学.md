- 1.整数反转
- 剑指31.整数中1出现的次数
- 剑指12.数值的整数次方
- 剑指33.丑数
- 剑指47.求1+2+3+...+n
- 剑指41.和为S的连续正数序列
- 剑指51.构建乘积数组

## 1.整数反转 ##

7.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

	class Solution {
	    public int reverse(int x) {
	        int result = 0;
	        while(x != 0){
	            int k = x%10;
	            x = x/10;
	            if(result > Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE/10 && k > 7)) return 0;
	            if(result < Integer.MIN_VALUE/10 || (result == Integer.MIN_VALUE/10 && k < -8)) return 0;
	            result = result*10 + k;
	        }
	        return result;
	    }
	}

## 剑指31.整数中1出现的次数 ##

求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

思路：

将一个数字中1出现的次数拆成个、十、百位中1出现次数的和以321为例：  

- cnt = 32 + 1，把321拆成高位32和1，固定个位是1，高位的取值可以是0~31共32个数，由于低位为1大于0，所以高位还可以取32（即数字321），则个位上1出现的次数是32+1=33 
- cnt = 30 + 10，把321拆成高位3和21，固定十位是1，高位可以取 0 ~ 2 共30个数，由于低位是21-10+1大于0，所以高位还可以取3（即数字310~319），则十位上1出现的次数是30 + 10 = 40 
- cnt = 0 + 100，把321拆成高位0和321，固定百位是1，高位可以取 0 个数，由于低位是321-100+1大于0，所以可以取数字100~199），则百位上1出现的次数是0 + 100 = 100  

所以321中1出现的次数是173

	public class Solution {
	    public int NumberOf1Between1AndN_Solution(int n) {
	        int cnt = 0, i = 1;
	        while(i<=n){
	            cnt += n / (i * 10) * i + Math.min(Math.max(n % (i * 10) - i + 1, 0), i);
	            i *= 10;
	        }
	        return cnt;
	    }
	}

## 剑指12.数值的整数次方 ##

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 

保证base和exponent不同时为0 

思路：

exponent可能为正可能为负。

	public class Solution {
	    public double Power(double base, int exponent) {
	        //if(exponent == 0) return 1.0;
	        double result = 1.0;
	        for(int i = 0; i < exponent; i++){
	            result *= base;
	        }
	        for(int i = 0; i > exponent; i--){
	            result /= base;
	        }
	        return result;
	  }
	}

## 剑指33.丑数 ##

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

思路：

每个丑数乘2，3，5都是丑数，每次记录最小的那个丑数,则该丑数序列是有序的。

如果x=y=z那么最小丑数一定是乘以2的，但关键是有可能存在x>y>z的情况，所以我们要维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，然后当其被选为新的最小值后，要把相应的指针+1；

	public class Solution {
	    public int GetUglyNumber_Solution(int index) {
	        if(index<=0) return 0;
	        int[] result = new int[index];
	        result[0] = 1;
	        int p2 = 0, p3 = 0, p5 = 0;
	        for(int i = 1; i < index; i++){
	            result[i] = Math.min(result[p2]*2, Math.min(result[p3]*3, result[p5]*5));
	            if(result[i] == result[p2]*2) p2++;
	            if(result[i] == result[p3]*3) p3++;
	            if(result[i] == result[p5]*5) p5++;
	        }
	        return result[index-1];
	    }
	}

## 剑指47.求1+2+3+...+n ##

求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

	public class Solution {
	    public int Sum_Solution(int n) {
	        //当n=0时，&&后面的就不会执行了，直接返回0
	        boolean flag = n>0 && (n += Sum_Solution(n-1)) > 0; 
	        return n;
	    }
	}

## 剑指41.和为S的连续正数序列 ##

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

思路：

遍历。注意边界问题。

	import java.util.ArrayList;
	public class Solution {
	    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
	        ArrayList<ArrayList<Integer> > result = new ArrayList<>();
	        for(int i = 1; i <= sum/2; i++){
	            int s = 0;
	            ArrayList<Integer> list = new ArrayList<>();
	            for(int j = i; j <= sum/2 + 1 && s < sum; j++){
	                list.add(j);
	                s += j;
	                if(s == sum) result.add(list);
	            }
	        }
	        return result;
	    }
	}

## 剑指51.构建乘积数组 ##

给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）


思路：

假设：

	left[i] = A[0]*...*A[i-1]
	right[i] = A[i+1]*...*A[n-1]
所以：

	B[i] = left[i] * right[i]

可知：

	left[i+1] = left[i] * A[i]
	right[i] = right[i+1] * A[i+1]

B[0]没有左，B[n-1]没有右。

	import java.util.Arrays;
	public class Solution {
	    public int[] multiply(int[] A) {
	        int n = A.length;
	        int[] B = new int[n];
	        if(n == 0) return B;
	        Arrays.fill(B,1);
	        for(int i = 1; i < n; i++){
	            B[i] = B[i-1]*A[i-1];
	        }
	        int temp = 1;
	        for(int i = n-2; i >= 0; i--){
	            temp *= A[i+1];
	            B[i] *= temp;
	        }
	        return B;
	    }
	}